---
title: (77)事件的委派
category: "javascript"
tags: ["javascript"]
description: "我们有一些超链接, 在初始化页面的时候就给他们绑定了单击响应函数。还有一个按钮可以动态添加超链接。但是新添加的超链接是没绑定点击事件的, 还需要去重新绑定。"
cover: https://cdn.jsdelivr.net/gh/zbglz/cdn@master/blog/md/javascript.svg
top_img: https://cdn.jsdelivr.net/gh/zbglz/cdn@master/blog/md/javascript.svg
toc: false
---

***

### 动态绑定事件

我们有一些超链接, 在初始化页面的时候就给他们绑定了单击响应函数。还有一个按钮可以动态添加超链接。但是新添加的超链接是没绑定点击事件的, 还需要去重新绑定。


```js js
<button id="btn_a">点击添加超链接</button>
<ul id="ul_a">
  <li><a href="javascript:;">超链接一</a></li>
  <li><a href="javascript:;">超链接二</a></li>
  <li><a href="javascript:;">超链接三</a></li>
</ul>

<script>
  var allA = document.getElementsByTagName("a")
  var btn_a = document.getElementById("btn_a")
  var ul_a = document.getElementById("ul_a")
  
  Object.keys(allA).forEach(key =>{
    bind(allA[key], "click", function(){
      console.log("我是a的单击响应函数")
    })
  })
  bind(btn_a, "click", function(){
    var li = document.createElement("li")
    li.innerHTML = "<a href='javascript:;'>超链接</a>"
    bind(li.firstChild, "click", function(){
      console.log("我是a的单击响应函数")
    })
    ul_a.appendChild(li)
  })
  
  function bind(obj, eventStr, callback){
    if(obj.addEventListener){
      obj.addEventListener(eventStr, callback, false)
    }else{
      obj.attachEvent("on" + eventStr, function(){
        callback.call(obj)
      })
    }
  }
</script>
```


**需求**：我们希望只绑定一次事件, 即可应用到多个元素上, 即使元素是动态添加的。

**事件的委派**：我们可以尝试将其绑定给元素的共同祖先元素ul上, 这样点击任意a标签, 会一直冒泡到祖先元素上的点击事件。从而通过祖先元素的响应函数来处理事件。事件的委派是利用了冒泡, 可以减少事件绑定的次数, 提高出现的性能。


```js js
<button id="btn_b">点击添加超链接</button>
<ul id="u1_b">
  <li><a href="javascript:;">超链接一</a></li>
  <li><a href="javascript:;">超链接二</a></li>
  <li><a href="javascript:;">超链接三</a></li>
</ul>

<script>
  var u1_b = document.getElementById("u1_b")
  var btn_b = document.getElementById("btn_b")
  
  bind(u1_b, "click", function(){
    console.log("我是ul的单击响应函数")
  })
  bind(btn_b, "click", function(){
    var li = document.createElement("li")
    li.innerHTML = "<a href='javascript:;'>超链接</a>"
    u1_b.appendChild(li)
  })
  
  function bind(obj, eventStr, callback){
    if(obj.addEventListener){
      obj.addEventListener(eventStr, callback, false)
    }else{
      obj.attachEvent("on" + eventStr, function(){
        callback.call(obj)
      })
    }
  }
</script>
```


`但是`点击除了a以外的其他部分, 也会触发ul的点击事件, 不仅点击a会冒泡到ul的点击事件上, 点击li也会冒泡到ul的点击事件上, 我们期望的是, 触发事件的对象是我们期望的元素则执行, 不是的话就不执行。
这就需要判断当前点击的元素, 我们知道onclick事件是绑定在ul上的, 那点击时的this就是ul, 则不能通过this获取当前点击的元素。


**target**。


`target`可以返回触发事件的元素。


```js js
<button id="btn_c">点击添加超链接</button>
<ul id="u1_c">
  <li><a href="javascript:;" class="link">超链接一</a></li>
  <li><a href="javascript:;" class="link">超链接二</a></li>
  <li><a href="javascript:;" class="link">超链接三</a></li>
</ul>

<script>
  var u1_c = document.getElementById("u1_c")
  var btn_c = document.getElementById("btn_c")
  
  bind(u1_c, "click", function(event){
    event = event || window.event
    // 当然a的class可能不仅仅有link, 还可能有多的className, 这里还需要进行判断。
    // 这就利用冒泡, 实现事件的委派, 而不需要对期望的元素进行多次事件绑定。
    if(event.target.className == "link"){
      console.log(event.target.firstChild.nodeValue)
    }
  })
  bind(btn_c, "click", function(){
    var li = document.createElement("li")
    li.innerHTML = "<a href='javascript:;' class='link'>超链接</a>"
    u1_c.appendChild(li)
  })
  
  function bind(obj, eventStr, callback){
    if(obj.addEventListener){
      obj.addEventListener(eventStr, callback, false)
    }else{
      obj.attachEvent("on" + eventStr, function(){
        callback.call(obj)
      })
    }
  }
</script>
```


***
